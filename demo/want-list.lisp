(in-package :social-shopping)

(defmethod want-count ((product collectable) &key (default-list-p t))
  (let ((key (string-id product)))
    (or
     (if default-list-p
         (@ (invoke-graph-view 'in-want-list 'want-count :group-p t :key key)
            :value)
         (@ (invoke-graph-view 'has-membership 'collected-count :group-p t :key key)
            :value))
     0)))

(defmethod who-wants ((product collectable) &key skip limit (public-p t))
  (declare (special product))
  (if public-p
      (select (:skip skip :limit limit :flat t)
              (?customer)
              (lisp ?product product)
              (in-want-list ?product ?customer)
              (unique ?customer)
              (node-slot-value ?customer visible-in-search ?visible)
              (= ?visible t))
      (select (:skip skip :limit limit :flat t)
              (?customer)
              (lisp ?product product)
              (in-want-list ?product ?customer)
              (unique ?customer))))

(defmethod want-list-wall ((customer customer) &key limit skip)
  (declare (special customer))
  (map-query 'offer-wall-view
             (select (:flat nil :limit limit :skip skip)
                     (?item)
                     (lisp ?customer customer)
                     (in-want-list ?item ?customer))
             :collect-p t))

(defmethod want-list-length ((customer customer))
  (or (@ (invoke-graph-view 'in-want-list
                            'list-length
                            :group-p t
                            :key (string-id customer))
         :value)
      0))

(defmethod want-list ((customer customer) &key limit skip)
  (declare (special customer))
  (select (:flat t :limit limit :skip skip)
          (?item)
          (lisp ?customer customer)
          (in-want-list ?item ?customer)))

(def-global-prolog-functor gender-match/2 (item wanted-gender cont)
  (setq wanted-gender (var-deref wanted-gender)
        item (var-deref item))
  (let ((actual-gender (gender item)))
    (when (or (null wanted-gender)
              (eql :any wanted-gender)
              (equalp actual-gender "neuter")
              (equalp actual-gender wanted-gender))
      (funcall cont))))

(def-global-prolog-functor taxon-match/2 (item wanted-taxon cont)
  (setq wanted-taxon (var-deref wanted-taxon)
        item (var-deref item))
  (if (or (null wanted-taxon)
          (eql :any wanted-taxon))
      (funcall cont)
      (let ((taxons (social-shopping::taxons item)))
        (when taxons
          (when (member wanted-taxon taxons :test 'node-equal)
            (funcall cont))))))

(def-global-prolog-functor price-between/3 (item low high cont)
  (setq low (var-deref low)
        high (var-deref high)
        item (var-deref item))
  (cond ((or (product-bookmarklet-p item)
             (product-p item))
         (when (and (<= (price item) high)
                    (>= (price item) low))
           (funcall cont)))
        (t
         (funcall cont))))

(defmethod filter-want-list ((customer customer) &key skip (limit nil)
                             price-low price-high gender taxon)
  (declare (special customer gender price-low price-high taxon))
  (unless gender (setq gender :any))
  (if (equalp gender "neuter") (setq gender :any))
  (cond ((null taxon)
         (setq taxon :any))
        ((stringp taxon)
         (setq taxon (lookup-taxon-by-key taxon))))
  (unless price-low (setq price-low 0))
  (unless price-high (setq price-high 100000000))
  (select (:limit limit :skip skip :flat t)
          (?product)
          (lisp ?customer customer)
          (lisp ?preferred-taxon taxon)
          (lisp ?gender gender)
          (lisp ?price-low price-low)
          (lisp ?price-high price-high)
          (in-want-list ?product ?customer)
          (gender-match ?product ?gender)
          (taxon-match ?product ?preferred-taxon)
          (price-between ?product ?price-low ?price-high)))
;          (has-taxon ?product ?taxon)
;          (node-slot-value ?taxon key ?taxon-name)
;          (or (= ?preferred-taxon :any)
;              (= ?taxon-name ?preferred-taxon))
;
;          (unique ?product)
;
;          (node-slot-value ?product price ?price)
;          (<= ?price ?price-high)
;          (>= ?price ?price-low)))

(defmethod item-in-want-list-p ((customer customer) (product collectable))
  (declare (special customer product))
  (select-one (?product)
              (lisp ?customer customer)
              (lisp ?product product)
              (in-want-list ?product ?customer)))

(defmethod wanted-p ((customer customer) (product collectable))
  (item-in-want-list-p customer product))

(defmethod in-which-want-lists ((customer customer) (product collectable))
  (when (item-in-want-list-p customer product)
    (list "default")))

(defmethod add-to-want-list ((customer customer) (product collectable))
  (with-write-locked-customer (customer)
    (or (wanted-p customer product)
        (make-in-want-list :from product :to customer :date-added (now)))))

(defmethod remove-from-want-list ((customer customer) (product collectable))
  (with-write-locked-customer (customer)
    (map-edges (lambda (edge)
                 (mark-deleted edge))
               *graph*
               :from-vertex product
               :to-vertex customer
               :edge-type 'in-want-list))
  (update-popularity product))

(defmethod delete-want-list ((customer customer))
  (with-write-locked-customer (customer)
    (map-edges (lambda (edge)
                 (let ((product (from edge)))
                   (mark-deleted edge)
                   (update-popularity product)))
               *graph*
               :to-vertex customer
               :edge-type 'in-want-list)))

(defun convert-all-want-lists ()
  (dolist (pair (select ()
                        (?wl ?owner)
                        (is-a ?wl want-list)
                        (has-want-list ?owner ?wl)))
    (let ((wl (first pair)) (customer (second pair)))
      (declare (special wl))
      (dbg "Handling want list ~A for ~A" wl customer)
      (dolist (item (select-flat (?i)
                                 (lisp ?wl wl)
                                 (in-want-list ?i ?wl)))
        (unless (item-in-want-list-p customer item)
          (dbg "    ~A" item)
          (make-in-want-list :from item
                             :to customer
                             :date-added (now))
          ))
      (mark-deleted wl)
      )))
